{"version":3,"sources":["../../../plugins/variants/src/VcfTabixAdapter/VcfTabixAdapter.ts"],"names":["configured","this","vcfGzLocation","readConfObject","config","location","indexType","filehandle","openLocation","isCSI","vcf","TabixIndexedFile","csiFilehandle","undefined","tbiFilehandle","chunkCacheSize","chunkSizeLimit","getHeader","then","header","parser","VcfParser","catch","e","opts","configure","getReferenceSequenceNames","a","getMetadata","query","ObservableCreate","observer","refName","start","end","getLines","lineCallback","line","fileOffset","next","VcfFeature","variant","parseLine","id","complete","signal","regions","superGetFeaturesInMultipleRegions","bytesForRegions","bytes","stat","pct","Math","round","size","console","warn","call","subscribe","Promise","all","map","region","index","blocksForRange","blockResults","byteRanges","forEach","blocks","block","minv","blockPosition","maxv","find","range","min","max","push","reduce","b","BaseFeatureDataAdapter"],"mappings":"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","file":"static/js/74.a00216ac.chunk.js","sourcesContent":["import {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport {\n  FileLocation,\n  NoAssemblyRegion,\n  Region,\n} from '@jbrowse/core/util/types'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { Feature } from '@jbrowse/core/util/simpleFeature'\nimport { TabixIndexedFile } from '@gmod/tabix'\nimport { GenericFilehandle } from 'generic-filehandle'\nimport VcfParser from '@gmod/vcf'\nimport { Observer } from 'rxjs'\nimport { readConfObject } from '@jbrowse/core/configuration'\nimport VcfFeature from './VcfFeature'\n\nexport default class extends BaseFeatureDataAdapter {\n  protected configured?: Promise<{\n    vcf: TabixIndexedFile\n    parser: typeof VcfParser\n    filehandle: GenericFilehandle\n  }>\n\n  protected async configure() {\n    if (!this.configured) {\n      const vcfGzLocation = readConfObject(this.config, 'vcfGzLocation')\n      const location = readConfObject(this.config, ['index', 'location'])\n      const indexType = readConfObject(this.config, ['index', 'indexType'])\n\n      const filehandle = openLocation(vcfGzLocation as FileLocation)\n      const isCSI = indexType === 'CSI'\n      const vcf = new TabixIndexedFile({\n        filehandle,\n        csiFilehandle: isCSI ? openLocation(location) : undefined,\n        tbiFilehandle: !isCSI ? openLocation(location) : undefined,\n        chunkCacheSize: 50 * 2 ** 20,\n        chunkSizeLimit: 1000000000,\n      })\n\n      this.configured = vcf\n        .getHeader()\n        .then(header => ({\n          filehandle,\n          vcf,\n          parser: new VcfParser({ header }),\n        }))\n        .catch(e => {\n          this.configured = undefined\n          throw e\n        })\n    }\n    return this.configured\n  }\n\n  public async getRefNames(opts: BaseOptions = {}) {\n    const { vcf } = await this.configure()\n    return vcf.getReferenceSequenceNames(opts)\n  }\n\n  async getHeader() {\n    const { vcf } = await this.configure()\n    return vcf.getHeader()\n  }\n\n  async getMetadata() {\n    const { parser } = await this.configure()\n    return parser.getMetadata()\n  }\n\n  public getFeatures(query: NoAssemblyRegion, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const { refName, start, end } = query\n      const { vcf, parser } = await this.configure()\n      await vcf.getLines(refName, start, end, {\n        lineCallback: (line: string, fileOffset: number) => {\n          observer.next(\n            new VcfFeature({\n              variant: parser.parseLine(line),\n              parser,\n              id: `${this.id}-vcf-${fileOffset}`,\n            }),\n          )\n        },\n        ...opts,\n      })\n      observer.complete()\n    }, opts.signal)\n  }\n\n  /**\n   * Checks if the data source has data for the given reference sequence,\n   * and then gets the features in the region if it does\n   *\n   * Currently this just calls getFeatureInRegion for each region. Adapters that\n   * are frequently called on multiple regions simultaneously may want to\n   * implement a more efficient custom version of this method.\n   *\n   * Also includes a bit of extra logging to warn when fetching a large portion\n   * of a VCF\n   * @param regions - Regions\n   * @param opts - Feature adapter options\n   * @returns Observable of Feature objects in the regions\n   */\n  public getFeaturesInMultipleRegions(\n    regions: Region[],\n    opts: BaseOptions = {},\n  ) {\n    // TODO: restore commented version below once TSDX supports Rollup v2\n    // xref: https://github.com/rollup/rollup/blob/master/CHANGELOG.md#bug-fixes-45\n    const superGetFeaturesInMultipleRegions = super.getFeaturesInMultipleRegions\n    return ObservableCreate<Feature>(async (observer: Observer<Feature>) => {\n      const bytes = await this.bytesForRegions(regions)\n      const { filehandle } = await this.configure()\n      const stat = await filehandle.stat()\n      let pct = Math.round((bytes / stat.size) * 100)\n      if (pct > 100) {\n        // this is just a bad estimate, make 100% if it goes over\n        pct = 100\n      }\n      if (pct > 60) {\n        console.warn(\n          `getFeaturesInMultipleRegions fetching ${pct}% of VCF file, but whole-file streaming not yet implemented`,\n        )\n      }\n      superGetFeaturesInMultipleRegions\n        .call(this, regions, opts)\n        .subscribe(observer)\n      // super.getFeaturesInMultipleRegions(regions, opts).subscribe(observer)\n    })\n  }\n\n  /**\n   * get the approximate number of bytes queried from the file for the given\n   * query regions\n   * @param regions - list of query regions\n   */\n  private async bytesForRegions(regions: Region[]) {\n    const { vcf } = await this.configure()\n    const blockResults = await Promise.all(\n      regions.map(region =>\n        // @ts-ignore\n        vcf.index.blocksForRange(region.refName, region.start, region.end),\n      ),\n    )\n    interface ByteRange {\n      start: number\n      end: number\n    }\n    interface VirtualOffset {\n      blockPosition: number\n    }\n    interface Block {\n      minv: VirtualOffset\n      maxv: VirtualOffset\n    }\n    const byteRanges: ByteRange[] = []\n    blockResults.forEach((blocks: Block[]) => {\n      blocks.forEach(block => {\n        const start = block.minv.blockPosition\n        const end = block.maxv.blockPosition + 64000\n        if (\n          !byteRanges.find(range => {\n            if (range.start <= end && range.end >= start) {\n              range.start = Math.min(range.start, start)\n              range.end = Math.max(range.end, end)\n              return true\n            }\n            return false\n          })\n        ) {\n          byteRanges.push({ start, end })\n        }\n      })\n    })\n\n    return byteRanges.reduce((a, b) => a + b.end - b.start + 1, 0)\n  }\n\n  public freeResources(/* { region } */): void {}\n}\n"],"sourceRoot":""}