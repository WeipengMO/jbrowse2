{"version":3,"sources":["../../../plugins/variants/src/VcfAdapter/VcfAdapter.ts"],"names":["readVcf","f","lines","split","header","refNames","rest","forEach","line","startsWith","push","join","VcfAdapter","config","setupP","vcfLocation","readConfObject","this","openLocation","readFile","fileContents","TextDecoder","unzip","decode","toString","decodeFileContents","a","parser","VCF","getMetadata","map","index","VcfFeature","variant","parseLine","id","getLines","region","opts","ObservableCreate","observer","setup","get","refName","start","end","next","complete","signal","BaseFeatureDataAdapter","capabilities"],"mappings":"ySAcMA,EAAU,SAACC,GACf,IAAMC,EAAQD,EAAEE,MAAM,MAChBC,EAAmB,GACnBC,EAAqB,GACrBC,EAAiB,GAUvB,OATAJ,EAAMK,SAAQ,SAAAC,GACRA,EAAKC,WAAW,YAClBJ,EAASK,KAAKF,EAAKL,MAAM,iBAAiB,GAAGA,MAAM,KAAK,IAC/CK,EAAKC,WAAW,KACzBL,EAAOM,KAAKF,GACHA,GACTF,EAAKI,KAAKF,MAGP,CAAEJ,OAAQA,EAAOO,KAAK,MAAOT,MAAOI,EAAMD,aAG9BO,E,kDAKnB,WAAmBC,GAA+B,kCAChD,cAAMA,IAHAC,YAE0C,I,6FAIlD,6FACQC,EAAcC,yBAClBC,KAAKJ,OACL,eAHJ,SAM2BK,uBAAaH,GAAaI,WANrD,UAS+B,kBAHzBC,EANN,QASwB,IACA,KAApBA,EAAa,IACc,kBAApBA,EAAa,IACA,MAApBA,EAAa,IACc,kBAApBA,EAAa,IACA,IAApBA,EAAa,GAdjB,6BAgBmB,IAAIC,YAhBvB,SAgBkDC,gBAAMF,GAhBxD,mBAgBIA,EAhBJ,KAgBqCG,OAhBrC,wCAkBIH,EAAeA,EAAaI,WAlBhC,iCAqBSxB,EAAQoB,IArBjB,iD,oHAwBA,sGAC2BH,KAAKQ,qBADhC,uBACUrB,EADV,EACUA,OADV,kBAESA,GAFT,gD,sHAKA,gCAAAsB,EAAA,sEAC2BT,KAAKQ,qBADhC,uBACUrB,EADV,EACUA,OACFuB,EAAS,IAAIC,IAAI,CAAExB,OAAQA,IAFnC,kBAGSuB,EAAOE,eAHhB,gD,mHAMA,iHACkCZ,KAAKQ,qBADvC,uBACUrB,EADV,EACUA,OAAQF,EADlB,EACkBA,MAEVyB,EAAS,IAAIC,IAAI,CAAExB,OAAQA,IAHnC,kBAKSF,EAAM4B,KAAI,SAACtB,EAAMuB,GACtB,OAAO,IAAIC,IAAW,CACpBC,QAASN,EAAOO,UAAU1B,GAC1BmB,SACAQ,GAAI,GAAF,OAAK,EAAKA,GAAV,gBAAoBJ,SAT5B,gD,gHAcA,qFACOd,KAAKH,SACRG,KAAKH,OAASG,KAAKmB,YAFvB,kBAISnB,KAAKH,QAJd,gD,sHAOA,wIAA0C,GAA1C,SAC6BG,KAAKQ,qBADlC,uBACUpB,EADV,EACUA,SADV,kBAESA,GAFT,gD,+EAKA,SAAmBgC,GAAwC,WAAxBC,EAAwB,uDAAJ,GACrD,OAAOC,2BAAgB,uCAAU,WAAMC,GAAN,SAAAd,EAAA,sEACX,EAAKe,QADM,cAEzBlC,SAAQ,SAAAN,GAEVA,EAAEyC,IAAI,aAAeL,EAAOM,SAC5B1C,EAAEyC,IAAI,OAASL,EAAOO,OACtB3C,EAAEyC,IAAI,SAAWL,EAAOQ,KAExBL,EAASM,KAAK7C,MAGlBuC,EAASO,WAXsB,2CAAV,sDAYpBT,EAAKU,U,2BAGV,gB,GAtFsCC,0BAAnBrC,EACLsC,aAAe,CAAC,cAAe","file":"static/js/73.859decec.chunk.js","sourcesContent":["import {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { FileLocation, Region } from '@jbrowse/core/util/types'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { Feature } from '@jbrowse/core/util/simpleFeature'\nimport { readConfObject } from '@jbrowse/core/configuration'\nimport { AnyConfigurationModel } from '@jbrowse/core/configuration/configurationSchema'\nimport VcfFeature from '../VcfTabixAdapter/VcfFeature'\nimport VCF from '@gmod/vcf'\nimport { unzip } from '@gmod/bgzf-filehandle'\n\nconst readVcf = (f: string) => {\n  const lines = f.split('\\n')\n  const header: string[] = []\n  const refNames: string[] = []\n  const rest: string[] = []\n  lines.forEach(line => {\n    if (line.startsWith('##contig')) {\n      refNames.push(line.split('##contig=<ID=')[1].split(',')[0])\n    } else if (line.startsWith('#')) {\n      header.push(line)\n    } else if (line) {\n      rest.push(line)\n    }\n  })\n  return { header: header.join('\\n'), lines: rest, refNames }\n}\n\nexport default class VcfAdapter extends BaseFeatureDataAdapter {\n  public static capabilities = ['getFeatures', 'getRefNames']\n\n  private setupP?: Promise<Feature[]>\n\n  public constructor(config: AnyConfigurationModel) {\n    super(config)\n  }\n\n  private async decodeFileContents() {\n    const vcfLocation = readConfObject(\n      this.config,\n      'vcfLocation',\n    ) as FileLocation\n\n    let fileContents = await openLocation(vcfLocation).readFile()\n\n    if (\n      typeof fileContents[0] === 'number' &&\n      fileContents[0] === 31 &&\n      typeof fileContents[1] === 'number' &&\n      fileContents[1] === 139 &&\n      typeof fileContents[2] === 'number' &&\n      fileContents[2] === 8\n    ) {\n      fileContents = new TextDecoder().decode(await unzip(fileContents))\n    } else {\n      fileContents = fileContents.toString()\n    }\n\n    return readVcf(fileContents)\n  }\n\n  public async getHeader() {\n    const { header } = await this.decodeFileContents()\n    return header\n  }\n\n  async getMetadata() {\n    const { header } = await this.decodeFileContents()\n    const parser = new VCF({ header: header })\n    return parser.getMetadata()\n  }\n\n  public async getLines() {\n    const { header, lines } = await this.decodeFileContents()\n\n    const parser = new VCF({ header: header })\n\n    return lines.map((line, index) => {\n      return new VcfFeature({\n        variant: parser.parseLine(line),\n        parser,\n        id: `${this.id}-vcf-${index}`,\n      })\n    })\n  }\n\n  public async setup() {\n    if (!this.setupP) {\n      this.setupP = this.getLines()\n    }\n    return this.setupP\n  }\n\n  public async getRefNames(_: BaseOptions = {}) {\n    const { refNames } = await this.decodeFileContents()\n    return refNames\n  }\n\n  public getFeatures(region: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const feats = await this.setup()\n      feats.forEach(f => {\n        if (\n          f.get('refName') === region.refName &&\n          f.get('end') > region.start &&\n          f.get('start') < region.end\n        ) {\n          observer.next(f)\n        }\n      })\n      observer.complete()\n    }, opts.signal)\n  }\n\n  public freeResources(): void {}\n}\n"],"sourceRoot":""}